#+OPTIONS: ^:nil
* Comint
Add your notes here
** The Theory
*** core
**** spawning a process
**** redirecting pipes to Emacs or use pseudo-terminal
***** pipes
****** stdin
****** stdout
****** stderr
***** depends on ~process-connection-type~
*** fundamental building blocks
**** process interaction
***** start-process
somewhat asynchronous
***** call-process
synchronous
**** basic interpreter framework
***** used by various REPLs
**** handles
***** input/output
***** command history
*** Use
**** comint-run
***** only one argument
****** experiment
#+BEGIN_EXAMPLE
(comint-run "~/bin/lfe")
#+END_EXAMPLE
Takes me to Erlang shell, why?
also M-x shell the running lfe
******* explanation
#+BEGIN_EXAMPLE
The reason for getting the erlang shell from within that shell is how you
erlang/lfe gets its input the erlang start is rather sensitive and it if can't
open a proper input tty it just defaults to the erlang shell might work with
m-x ansi-term If you check the inferior-lfe function in inferior-lfe.el you
will see the work we goto to get the input right
#+END_EXAMPLE
**** make-comint-in-buffer
not tried yet
**** pipe redirection
Some programs disable shell prompt when they detect redirection of their pipes
to a dumb terminal. If there's no interactive mode running M-x shell might help.
**** list all processes
M-x list-processes
** Writing a comint mode
